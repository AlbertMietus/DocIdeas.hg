{DRAFT] Integration a FSM in CastleCode (experiments)
*****************************************************

.. post:: 	
   :category: Castle, Language, rough
   :tags: Castle, DesignStudy, FSM

   As demanded by :need:`U_FSM_Syntax`, we need a syntax to define FSMs directly in CastleCode.

   The behavior of a FSM is defined by the its “rules”.  But to use a FSM we need to “call” that FSM; it needs to proces events,
   either by *single stepping* or in a *for-ever-loop*. This is typically a details that most developers like to
   controll.
   |BR|
   And so we need a bit of syntax (and semantics) for it.

A few experiments are already given in :ref:`FSM-rules-tries` -- which focus on the rules; and are mostly “internal” to
the FSM. In this blog we focus and experiments on how to integrate the FSM with the “rest of the CastleCode”.
|BR|
Unlike the ‘states’ -- which are internal details of the FSM--, the events and actions are external -- its are the
inputs and outputs of the FSM. So, the need to exist both ‘in’ and ‘outside’ the FSM.

.. caution::  Most of the shown CastleCode syntax is provisional.

   * Here, we use basic rule synax of :ref:`FSM-rules-try-1`,
   * But use the meta/decorator ``@FSM`` style to denote (which kind of) FSM it is. -- see references (below) on this
   * Sometimes `#events:` and ``#actions:`` lines are added as pseudo comments
     |BR|
     to show the inputs and outputs to the user. This is not part of the syntax


Questions
=========
Here, we focus (on experimenting) on how to intergrade it in CCastle

1. What ‘is’ a FSM?

   a) a component (by itself)
   #) a function (or other callable)
   #) just a "statement"

#. How do we *"call"* the FSM

   a) just sent events via a port?
   #) call `FSM.step()`, or `FSM.step(input)`
   #) call `FSM.run()` -- which may never return
   #) How about event parameters?

#. How about the actions that are called?

   a) Sending events over an output-port?
   #) Or do we execute local functions?
   #) How about outgoing parameters?



The Basic
=========

We use a very simple -- 2 states, 2 events, 4 actions-- FSM  called “Turnstile”. It has only 4 “rules”, and is easy to
understand.
|BR|
After this introduction, we will intergrade it with demo code (in several ways) to answer the questions above.

.. tabs::

   .. code-tab:: ReasonML The Turnstile FSM

      @FSM
      Turnstile {
        state: Locked, Unlocked;
        #events: coin, pass;
        #actions: unlock, alarm, thankyou, lock;

         // State + event -> State, action();
         Locked   + coin  -> Unlocked, unlock();
         Locked   + pass  -> Locked,   alarm();
         Unlocked + coin  -> Unlocked, thank_you();
         Unlocked + pass  -> Locked,   lock();
      }

   .. tab:: References

      * This Turnstile FSM is based on #UncleBob’s  State Machine Compiler demo. 
      * The "@FSM" is based on python's decorator and CPP2's ‘Metaclass functions’

   .. tab:: Links

      * SMC/Turnstile: https://github.com/unclebob/CC_SMC
      * CPP2: https://github.com/hsutter/cppfront and https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0707r4.pdf (a bit old)



Experimenting
=============

.. ToDo:: all
