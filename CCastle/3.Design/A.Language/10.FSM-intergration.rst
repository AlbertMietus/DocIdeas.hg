.. include:: /std/localtoc.irst

=======================================================
[DRAFT] Integration a FSM in CastleCode (experimenting)
=======================================================

.. post:: 	
   :category: Castle, Language, rough
   :tags: Castle, DesignStudy, FSM

   As demanded by :need:`U_FSM_Syntax`, we need a syntax to define FSMs directly in CastleCode.

   The behavior of a FSM is defined by the its “rules”.  But to use a FSM we need to “call” that FSM; it needs to proces events,
   either by *single stepping* or in a *for-ever-loop*. This is typically a details that most developers like to
   controll.
   |BR|
   And so we need a bit of syntax (and semantics) for it.

A few experiments are already given in :ref:`FSM-rules-tries` -- which focus on the rules; and are mostly “internal” to
the FSM. In this blog we focus and experiments on how to integrate the FSM with the “rest of the CastleCode”.
|BR|
Unlike the ‘states’ -- which are internal details of the FSM--, the events and actions are external -- its are the
inputs and outputs of the FSM. So, the need to exist both ‘in’ and ‘outside’ the FSM.

.. caution::  Most of the shown CastleCode syntax is provisional.

   * Here, we use basic rule synax of :ref:`FSM-rules-try-1`,
   * But use the meta/decorator ``@FSM`` style to denote (which kind of) FSM it is. -- see references (below) on this
   * Sometimes `#events:` and ``#actions:`` lines are added as pseudo comments
     |BR|
     to show the inputs and outputs to the user. This is not part of the syntax

Intro
*****

This blog shows a few possible implementations of a simle “Turnstile” FSM, to experiment with syntax options. We use a
basic version, and we will extend it too -- to show wat it does with the code.

Questions
=========

The experiments -- how to intergrade an FSM into CCastle focus around the following questions.

.. include:: FSM-questions.irst


Turnstile demo
==============

We use a very simple -- 2 states, 2 events, 4 actions-- FSM  called “Turnstile”. It has only 4 “rules”, and is easy to
understand.
|BR|
Later, we will add more stated (requesting 2 coins) and/or non-FSM behavior, like counting the (total number of) coins

.. include:: FSM-Turnstile.isrt


Experimenting
*************

FSM as Component
================

When an component is implemented as an FSM (using the “:ref:`Rewriters`”: `@FSM`) the in-ports are used as FSM-inputs and the
out-port can be used for actions. So, “calling” the FSM is like “calling” any other component: send signales over the
connections.
|BR|
Note: There is no need to that alls FSM-inputs (nor it outputs) match 1:1 to the protocol of one port -- the can
originate from multiple in-ports and protocols.

.. tabs::

   .. tab:: IO

      .. literalinclude:: code/Turnstile_Component.Castle
         :language: ReasonML
         :lines: 1-15
         :emphasize-lines: 2-3, 7-8, 12

   .. tab:: Interface

      .. literalinclude:: code/Turnstile_Component.Castle
         :language: ReasonML
         :lines: 16-20

   .. tab:: @FSM
      :selected:

      .. literalinclude:: code/Turnstile_Component.Castle
         :language: ReasonML
         :lines: 22-

      .. hint:: `@FSM` (a :ref:`Rewriters`) will “expanded” this code to equivalent CCastle-Code as shown in the next tab.

         That is, is not really generated as in most code-generators.
         |BR|
         It only exist inside the compiler, and is typically only exist in AST (actually: :ref:`AIGR<AIGR>`) format --
         not as text.


   .. tab:: Rewritten

      .. literalinclude:: code/Turnstile_Component_Rewritten.Castle
         :language: ReasonML

      .. admonition:: Code generated at AST level

         The Rewritten (see: ref:`Rewriters`) code will result in the same AST/:ref:`AIGR<AIGR>` as the original @FSM one.


Eval (Component)
~~~~~~~~~~~~~~~~

I like this variant.
|BR|
The Turnstile FSM shows that a basic FSM in this style is very clean, and simple

FSM as function
===============
ToDo

Eval (function)
~~~~~~~~~~~~~~~~
ToDo

FSM as (Data)Class
==================

.. error:: Class? Of Data-Classes? Or Struct’s

   Until now, “classes” are hardly used in CCastle -- they are kind-of replace by Components. Components however are
   always “active”, and we may/probably need passive “data-clases” too -- e.g  the AIGR has only data-clases.

   .. hint:: As an FSM has state and behavior, a class sounds better then a Data-Class/Structure. But is it

.. hint::

   As an FSM has *state*, it needs “memory”, and is typically implemented as a instantiated class in many
   language.

   .. Caution:: Some design-patterns use classes (with no data; and hardly an instance) for “hold” the callables for
      each state.

      That is more namespace then a class.
      And surely not a data-class

Eval (Data/Class)
~~~~~~~~~~~~~~~~~
ToDo
