.. include:: /std/localtoc.irst

=======================================================
[DRAFT] Integration a FSM in CastleCode (experimenting)
=======================================================

.. post:: 	
   :category: Castle, Language, rough
   :tags: Castle, DesignStudy, FSM

   As demanded by :need:`U_FSM_Syntax`, we need a syntax to define FSMs directly in CastleCode.

   The behavior of a FSM is defined by the its “rules”.  But to use a FSM we need to “call” that FSM; it needs to proces events,
   either by *single stepping* or in a *for-ever-loop*. This is typically a details that most developers like to
   controll.
   |BR|
   And so we need a bit of syntax (and semantics) for it.

A few experiments are already given in :ref:`FSM-rules-tries` -- which focus on the rules; and are mostly “internal” to
the FSM. In this blog we focus and experiments on how to integrate the FSM with the “rest of the CastleCode”.
|BR|
Unlike the ‘states’ -- which are internal details of the FSM--, the events and actions are external -- its are the
inputs and outputs of the FSM. So, the need to exist both ‘in’ and ‘outside’ the FSM.


Intro
*****

This blog shows a few possible implementations of a simle, well-known *Turnstile* FSM, to experiment with syntax options. We use a
basic version, and we will extend it -- to show wat it does with the code.

Questions
=========

The experiments -- how to intergrade an FSM into CCastle focus around the following questions.

.. include:: FSM-questions.irst


Turnstile demo
==============

We use a very simple -- 2 states, 2 events, 4 actions-- FSM  called “Turnstile”. It has only 4 “rules”, and is easy to
understand.
|BR|
Later, we will add more stated (requesting 2 coins) and/or non-FSM behavior, like counting the (total number of) coins

.. include:: FSM-Turnstile.isrt


Experimenting
*************

.. caution::  Most of the shown CastleCode syntax is provisional.

   * Here, we use basic rule synax of :ref:`FSM-rules-try-1`,
   * I use ``@FSM`` (see: “:ref:`Rewriters`”) as a kind of
     (Python) (`decorator <https://docs.python.org/3/glossary.html#term-decorator>`__) or
     CPP2 [#cpp2]_ metafunction `(video-link) <https://www.youtube.com/watch?v=fJvPBHErF2U&t=2590s>`__
   * I use some “ad hoc syntax, for trivial thinks, I did’t design yet (e.g. Enum).
   * The order of names and typs are not consistent ``name ‘:’ type [‘:=’ value]``
     vs ``type ‘:’ name`` -- sorry for that; my tought are not final, and my fingers type differently:-)


FSM as Component
================

When an component is implemented as an FSM (using the “:ref:`Rewriters`”: `@FSM`) the in-ports are used as FSM-inputs and the
out-port can be used for actions. So, “calling” the FSM is like “calling” any other component: send signales over the
connections.
|BR|
Note: There is no need to that alls FSM-inputs (nor it outputs) match 1:1 to the protocol of one port -- the can
originate from multiple in-ports and protocols.

.. include:: FSM-Turnstile-Basics.irst

Eval (Component)
~~~~~~~~~~~~~~~~

I like this variant.
|BR|
The Turnstile FSM shows that a basic FSM in this style is very clean, and simple

FSM as function
===============
ToDo

Eval (function)
~~~~~~~~~~~~~~~~
ToDo

FSM as (Data)Class
==================

.. error:: Class? Of Data-Classes? Or Struct’s

   Until now, “classes” are hardly used in CCastle -- they are kind-of replace by Components. Components however are
   always “active”, and we may/probably need passive “data-clases” too -- e.g  the AIGR has only data-clases.

   .. hint:: As an FSM has state and behavior, a class sounds better then a Data-Class/Structure. But is it

.. hint::

   As an FSM has *state*, it needs “memory”, and is typically implemented as a instantiated class in many
   language.

   .. Caution:: Some design-patterns use classes (with no data; and hardly an instance) for “hold” the callables for
      each state.

      That is more namespace then a class.
      And surely not a data-class

Eval (Data/Class)
~~~~~~~~~~~~~~~~~
ToDo



-------

.. rubric:: footnotes

.. [#cpp2]
   CPP2 is a language-study by Herb Sutter, see https://herbsutter.com/?s=cpp2 and https://github.com/hsutter/cppfront,
   to make a “better, safer” C++.
   |BR|
   It has some goals that are comparable with my CCastle goals -- but restrics itself to be C++ (with good arguments).

   Herb has a lot of experience and deep-tought; and so is a good inspiration.
