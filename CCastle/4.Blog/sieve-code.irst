.. -*-rst-*-
   included in  `b.TheSieve.rst`

.. NOTE the code-tabs use ReasonML , but it Castle-code!!

.. The "No Heisenbug" variant is used as base:    ``.../SIEVE/3.NoHeisenbug/CC-event-sieve.Castle``

Moat (*interfaces*)
===================


.. tabs::

   .. code-tab:: ReasonML Generator

      component Generator : Component {
        port StartSieve<in>:controll;
        port SimpleSieve<out>:outlet;
        port SimpleSieve<in>:collect;
      }

   .. code-tab:: ReasonML Sieve

      component Sieve(onPrime:int) : Component {
        port SimpleSieve<in>:try;
        port SimpleSieve<out>:coprime;
      }

   .. code-tab:: ReasonML Finder

      component Finder : Component {
        port SimpleSieve<in>:newPrime;
        port SimpleSieve<out>:found;
      }

Castle (*implementation*)
=========================

.. tabs::
   .. code-tab:: ReasonML Generator

      implement Generator {
        int maxValue;

      StartSieve.newMax(max) on self.controll
      {
        self.maxValue := max;
      }

      StartSieve.runTo(max) on self.controll
      {
        int i;

        self.maxValue := max;
        i:=0;
        while (i < self.maxValue) {
          self.outlet.input(i);
        }
      }

      SimpleSieve.input(foundPrime) on .collect
      {
        static int count:=0;
        count :+= 1;
        printf("Generator: Collected prime (no %s): %8i\n", count, foundPrime);
      }
      } //@end Generator

   .. code-tab:: ReasonML Sieve

      implement Sieve {
        int myPrime;

      -init(onPrime:int)
      {
        super.init();								//note 'super' acts as a port
        self.myPrime := onPrime;
      }

      SimpleSieve.input(try) on .try
      {
        if ( (try % self.myPrime) !=0 ) {
          self.coprime.input(try);
        }
      }
      } //@end Sieve

   .. code-tab:: ReasonML Finder

      implement Finder {

      SimpleSieve.input(foundPrime) on self.newPrime
      {
        // Send out the newPrime,
        self.found.input(foundPrime);
      }
      } //@end Finder

   .. code-tab:: ReasonML Main

      implement Main {
        sub generator;
        sub finder;
        alias lastSieve;         // The list of Sieve's grow dynamicly!; keep track of the last one

      -init()
      {
        self := super.init();

        .generator := Generator.new();
        .finder    := Finder.new();

        .generator.outlet = .finder.newPrime; // Initially, there aren't any Sieves
        self.lastSieve := Ground; // Not needed, as it is default. But is clearifies the code below
      }

      // We have build the sievelist (and reconnect) on a newly found prime ..
      SimpleSieve.try(newPrime) on self.generator.found
      {
        alias s;

        // Extent the sieve-list ...
        s:= Sieve.new(newPrime);
        s.coprime = self.finder.newPrime;
        if (not self.lastSieve == Ground) {              // .lastSieve == Ground, so not connected, so we have the first Sieve to connect to .generator
          self.generator.outlet = s.try;
          self.generator.outlet.queue.removeLimit();
        } else {
          self.lastSieve.coprime = s.try;
          self.lastSieve.coprime.queue.removeLimit();
        }
        .lastSieve := s;

        self.generator.collect.input(newPrime);   // forward the prime to the Generator
      }

      powerOn() on self.power
      {
        int max := 10;

        self.generator.runTo(max);
      }
      } //@end Main
